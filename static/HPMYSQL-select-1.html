<html xmlns="http://www.w3.org/1999/html">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
	<title>《高性能MySQL》-查询性能优化笔记（一）</title>
	<link href="./img/keller.ico" rel="shortcut icon" type="image/x-icon">
    <link href="./css/style.css" rel="stylesheet" />
	<link href="./css/zenburn.css" rel="stylesheet" />
	<script src="./js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>
	<body>
		<aside>
			<h1>
				<a>
					<img src="./img/keller.png">
					</img>
				</a>
			</h1>
			<p class="disc">
				欢迎来到我的博客
			</p>
			<p>
				<ul>
					<li><a href="/">主页</a></li>
					<li><a href="https://github.com/keller35">github</a></li>
					<li><a href="/links.html">links</a></li>
				</ul>
			</p>
		</aside>
		<section>
			<div>
				<p id="title">《高性能MySQL》-查询性能优化笔记（一）</p>
				<p id="date">2015-11-15</p>
			</div>
			<p>查询性能低下最基本的原因是访问的数据太多：</p>
<pre><code>1、查询不需要的数据
2、多表关联时返回全部列
     select * from a join b join c
3、总是取出全部列
     select *
4、重复查询相同的数据
</code></pre>
<p>如果没有查询过多的数据：</p>
<pre><code>1、扫描的行数和返回的行数尽量小
2、扫描的行数和访问类型
 explain中的type列
    （1）SYSTEM
        CONST特例，表中只有一条元组匹配
    （2）CONST
        WHERE条件筛选后表上至多有一条元组匹配时
    （3）EQ_REF(单值连接)
        参与连接运算的表是内表（在代码实现的算法中，两表连接时作为循环中的内循环遍历的对象，
        这样的表称为内表）。
        基于索引(连接字段上存在唯一索引或者主键索引，且操作符必须是“=”谓词，索引值不能为NULL)做扫描，
        使得对外表的一条元组，内表只有唯一一条元组与之对应。
    （4）REF(多值连接)
        可以用于单表扫描或者连接。参与连接运算的表，是内表。
        基于索引（连接字段上的索引是非唯一索引，操作符必须是“=”谓词，连接字段值不可为NULL）做扫描，
        使得对外表的一条元组，内表可有若干条元组与之对应。
    （5）REF_OR_NULL
        类似REF，只是搜索条件包括：连接字段的值可以为NULL的情况
    （6）RANGE
        范围扫描，基于索引做范围扫描，为诸如BETWEEN，IN，&gt;=，LIKE类操作提供支持
    （7）INDEX_SCAN
        索引做扫描，是基于索引在索引的叶子节点上找满足条件的数据（不需要访问数据文件）
    （8）ALL
        全表扫描或者范围扫描：不使用索引，顺序扫描，直接读取表上的数据（访问数据文件）
    （9）UNIQUE_SUBQUERY
        全表扫描或者范围扫描：不使用索引，顺序扫描，直接读取表上的数据（访问数据文件）
    （10）INDEX_SUBQUERY
        在子查询中，基于除唯一索引之外的索引进行扫描
    （11）INDEX_MERGE
        多重范围扫描。两表连接的每个表的连接字段上均有索引存在且索引有序，结果合并在一起。
        适用于作集合的并、交操作。
    （12）FT
        FULL TEXT，全文检索
 一般MySQL有如下三种应用where条件方式：
     1、在存储引擎层使用where条件过滤不匹配的记录,这是在存储引擎层完成的。
     2、在服务层完成索引覆盖扫描，直接从索引过滤不需要的记录并返回命中的结果，无需再回表查询
     3、在数据表中返回数据，然后过滤不满足条件的记录。
</code></pre>
<p>重构查询的方式：</p>
<pre><code>1、切分为多个简单小查询
2、分解关联查询
 1、让缓存的效率更高，在应用程序中缓存单表查询的结果。
 2、单表查询可以减少锁的竞争。
 3、在应用层对数据库进行拆分，更容易做到高性能和可扩展。
 4、可以减少冗余数据记录的查询。
</code></pre>
<p>查询优化处理：</p>
<pre><code>1、语法解析和预处理
2、查询优化器
 优化器将语法数转换成执行计划，在多条执行计划中找到最好的执行计划。
 可能自动执行以下操作：
     1、重新定义关联表的顺序
     2、将外连接转化成内连接
     3、使用等价变换规则：可以合并和减少一些操作
     4、优化count()、min()、max()，前者通常是一个常量，后两者可以通过索引直接获取
     5、预估并转化为常数表达式：ref中的const
     6、覆盖索引扫描
     7、子查询优化
     8、提前终止查询
     9、等值传播：如果两个列的值通过等式关联，MySQL会把其中一个列的where条件传递到另一个列上
     10、列表IN()的比较：在IN()大量取值的情况下，mysql效率会更高
</code></pre>
<p>3、数据和索引的统计信息</p>
<pre><code> 主要是服务器层向存储引擎获取数据和索引的统计信息
</code></pre>
<p>MySQL的关联查询：</p>
<pre><code> 先对第一个表查询，循环取出单条数据，然后对下一个表进行循环嵌套，查找匹配的行。
 关联查询优化:
      mysql会自动根据驱动表数量，决定关联表的嵌套循环顺序，使用STRAIGHT_JOIN可以强制控制嵌套顺序
</code></pre>
<p>排序优化：</p>
<pre><code> 排序成本高，尽量避免排序；数据量小在内存中进行，数据量大则使用磁盘。
 如果是表关联情况下的排序，有两种情况：
      1、排序字段来自第一个表，则在关联第一个表时就进行了排序，explain显示&quot;using filesort&quot;
      2、除此之外，MySQL会将关联结果存放在临时表，在关联结束后在进行排序，
      explain显示&quot;using temporary;using filesort&quot;
</code></pre>
<p>关联子查询：（exist、not exist）</p>
<pre><code> 先测试关联子查询的性能，然后进行优化；尽量使用表连接写法
 小技巧：
      (select * from a) union all (select * from b) limit 20
      可以写成
       (select * from a limit 20) union all (select * from b limit 20) limit 20
      减少查询数量</code></pre>


			<!-- 多说评论框 start -->
			<div class="ds-thread flat" data-thread-key="p13" data-title="《高性能MySQL》-查询性能优化笔记（一）" data-url="/HPMYSQL-select-1.html"></div>
			<!-- 多说评论框 end -->
			<!-- 多说分享 start -->
			<div class="ds-share flat" data-thread-key="p13" data-title="《高性能MySQL》-查询性能优化笔记（一）" data-images="/img/keller.png" data-content="《高性能MySQL》-查询性能优化笔记1" data-url="/HPMYSQL-select-1.html">
				<div class="ds-share-aside-right">
					<div class="ds-share-aside-inner">
					</div>
					<div class="ds-share-aside-toggle">分享到</div>
				</div>
			</div>
			<!-- 多说分享 end -->
			<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
			<script type="text/javascript">
				var duoshuoQuery = {short_name:"kellerblog"};
				(function() {
					var ds = document.createElement('script');
					ds.type = 'text/javascript';ds.async = true;
					ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					ds.charset = 'UTF-8';
					(document.getElementsByTagName('head')[0]
					|| document.getElementsByTagName('body')[0]).appendChild(ds);
				})();
			</script>
			<!-- 多说公共JS代码 end -->

        </section>
	</body>
</html>